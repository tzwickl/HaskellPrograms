module Exercise_14 where

import Data.List
import Test.QuickCheck

{- Library -- nicht veraendern -}

data Fml a = Var a | Neg (Fml a) | Conj [Fml a] | Disj [Fml a]
    deriving (Eq, Show)

{- G14.2 -}
-- user interface which concatenates a list of lists to a list
concat :: [[a]] -> [a]
concat list = concat' list []

-- tail-rekursive implementation of the concat function which uses an accumulator 
concat' :: [[a]] -> [a] -> [a]
concat'  []     acc = acc
concat' (x:xs) acc = concat' xs (x ++ acc)

{- G14.3 -}
threes = 3 : threes

{-
map (*2) (1 : threes ) !! 1
(!!) (map (*2) (1 : threes) 1
(!!) ((*2) 1 : map (*2) threes) 1
(!!) (map (*2) threes) 0
(!!) (map (*2) (3 : threes)) 0
(!!) ((*2) 3 : map (*2) threes) 0
(*2) 3
3 * 2
6
-}

{-
(\ f -> \ x -> x + f 2) (\ y -> y * 2) (3 + 1)
(\ f -> \ x -> x + f 2) (\ y -> y * 2) (3 + 1)
(3 + 1) + (\ y -> y * 2) 2
(3 + 1) + (2 * 2)
4 + 4
8
-}

{-
head ( filter (/=3) threes )
head ( filter (/=3) (3 : threes))
head ( filter (/=3) threes)
==> this function will never terminate because each element in threes is equal to three
    so the filter function goes on for every because there is never found a first element
    that can be extracted by the function head
-}

{- H14.1 -}

{- braucht nicht implementiert zu werden -- außer um ihre eigene Lösung zu testen -}
uniqueElems :: Eq a => [a] -> [a]
uniqueElems = nub

-- the first property tests if the result list generated by the function uniqueElems
-- does really not contain any duplicates
propUniqueElems1 :: [Int] -> Bool
propUniqueElems1 list = and $ map (\x -> length x == 1) $ 
						map (\ x -> filter (\ y -> x == y) uniqueList) uniqueList where
		uniqueList = uniqueElems list

-- the second property tests if the result list generated by the function uniqueElems
-- doesn't lose any elements
-- each element in the input list must also be contained in the result list
propUniqueElems2 :: [Int] -> Bool
propUniqueElems2 list = go list uniqueList where
		uniqueList  = uniqueElems list
		go []     _ = True
		go (x:xs) ys 
			| elem x ys = go xs ys
			| otherwise  = False
			
-- the third property tests if the result list generated by the function uniqueElems 
-- doesn't distort any elements
-- each element in the result list must also be contained in the input list
propUniqueElems3 :: [Int] -> Bool
propUniqueElems3 list = go uniqueList list where
		uniqueList  = uniqueElems list
		go []     _ = True
		go (x:xs) ys 
			| elem x ys = go xs ys
			| otherwise  = False

{- H14.2 -}
-- renames all variable names in the given equation by applying the given function
-- to each variable name
rename :: (a -> a) -> Fml a -> Fml a
rename f (Var a) 		= Var (f a)
rename f (Neg x) 		= Neg (rename f x)
rename f (Conj xs)		= Conj [rename f x| x <- xs]
rename f (Disj xs)	  	= Disj [rename f x| x <- xs]
